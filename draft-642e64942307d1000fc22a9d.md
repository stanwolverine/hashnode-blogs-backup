---
title: "Rust Testing for Developers: A Straightforward Guide ðŸ§ª"
slug: rust-testing-for-developers-a-straightforward-guide
cover: https://cdn.hashnode.com/res/hashnode/image/stock/unsplash/gT5kuls6Y6Q/upload/0e39342ed3de9ad6e0960758978e03db.jpeg

---

What to expect in this blog:

1. What is a test in the context of Rust?!
    
2. When does the test fail or pass?!
    
3. Where should we write tests?!
    
4. How to run tests?
    
5. What are some utility macros and attributes?
    
6. Bonus: test without panic
    
7. Integration Tests
    

## What is a Test in Rust

A function annotated with a `test` attribute is a Test in Rust, It can also be called a Test Function.

```rust
// Example 1: A Test in Rust

#[test]
fn should_add_two() {
    // write what you want to
    // test inside test function
}
```

This `test` attribute (`#[test]`) indicates that the following function is a Test Function, not a normal function.

## How to make a Test Fail or Pass

* **Test "fails" when the Test Function "**`panics`**"**
    
    We can call `panic!` macro explicitly or other code within our test function can invoke the `panic!` macro to mark a test as *"failed"*
    
    ```rust
    // Example 2: Making a Test Fail
    
    #[test]
    fn should_add_two() {
      // To make a Test fail:-
    
      // `panic` macro can be
      //   called explicitly
      panic!()
    
      // OR, other code or expression
      //   can also call `panic` macro
      function_which_calls_panic()
    }
    ```
    
* **Test "passes" when the Test Function finishes execution without any** `panics`
    

## Run your Tests

We can run `cargo test` command to run our tests. It will run all the test functions and show the result of the tests.

To run specific tests, We can provide the "name" or a "part of the name" of the test(s) to the `cargo test` command. Cargo will then run all the tests whose names contain the given text.

```bash
cargo test <Test_Name_Here>
```

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1685804517682/35692e3d-4024-4ddb-a9b2-19b308e6ae63.png align="center")

## Where to Write Tests

The simplest way to organize our tests is by putting them in the same file with the code they test. When we follow this approach, Rust will compile the tests along with the regular code when we run `cargo build` or `cargo run`, which is not desirable.

To solve this, We create a module named "tests" in the same file to contain all the tests.

```rust
// ... Regular Code Here ...

// In same file after regular code,
// Create module named "tests"
mod tests {
  // All of our tests will
  //   be written inside module
}
```

then, Add `#[cfg(test)]` attribute to the "tests" module, this attribute tells Rust to compile and run this code only when we run `cargo test` the command.

```rust
#[cfg(test)]
mod tests {
  // All of our tests will
  //   be written inside module
}
```

Now, when we write tests, we will notice that code outside of the tests module is not in scope and we are unable to use it. To use outside code, We have to bring it into the scope of the current module. We do this by using `use super::*` statement.

```rust
#[cfg(test)]
mod tests {
  // Bring outside code into scope
  use super::*;

  // All of our tests will be
  //   written here
}
```

Below code snippet shows a complete example of tests written with the code -

```rust
fn make_double(num: i32) -> i32 {
  return num * 2;
}

#[cfg(test)]
mod tests {
  // This brings `make_double`
  //   function into scope
  use super::*;

  #[test]
  fn should_make_double() {
    if make_double(4) != 8 {
      panic!();
    }
  }
}
```

To understand the above code snippet more, see the below image -

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1685789482745/54fb31cb-1ecd-40e4-bd33-64266942a4f5.png align="center")

## Assertion Utilities

1. `assert!` macro  
    The `assert!` the macro takes an expression as a first parameter and checks if that expression evaluates to `true`.
    
    If the given expression doesn't evaluate to `true`, `assert!` macro will invoke `panic!` macro for us and the test will be marked as failed.
    
    ```rust
    // Example 3: `assert!` macro usage
    
    #[test]
    fn passed_test() {
      let a = 1; let b = 3;
    
      // expression "a + b == 4"
      //   evaluates to `true`.
      // Thus, `assert!` macro will
      //   not invoke `panic!` macro
      assert!(a + b == 4);
    }
    
    #[test]
    fn failed_test() {
      let a = 2; let b = 2;
    
      // expression "a + b == 5"
      //   evaluates to `false`.
      // Thus, `assert!` macro will
      //   invoke `panic!` macro and
      //   test will be marked as "fail"
      assert!(a + b == 5);
    }
    ```
    
2. `assert_eq!` macro  
    The `assert_eq!` macro checks if the two expressions are equal to each other using double equal (`==`) comparison.
    
      
    If the two expressions are not equal, `assert_eq!` macro will invoke `panic!` macro for us and the test will be marked as failed.
    
    ```rust
    // Example 4: `assert_eq!` macro usage
    
    #[test]
    fn pass_test() {
      let a = 1; let b = 3;
    
      // left expression `a + b` is equal(==)
      //   to right expression `4`
      // Thus, `assert_eq!` macro
      //   will not invoke `panic!` macro
      assert_eq!(a + b, 4);
    }
    
    #[test]
    fn fail_test() {
      let a = 2; let b = 2;
    
      // left expression `a + b` is not equal(==)
      //   to right expression `5`
      // Thus, `assert_eq!` macro
      //   will invoke `panic!` macro
      assert_eq!(a + b, 5);
    }
    ```
    
3. `assert_ne!` macro  
    The `assert_ne!` macro is the opposite of `assert_eq!` macro.  
      
    Instead of checking for equality, It checks if the two expressions are *not equal* to each other using "not equal (`!=`)" comparison.
    
      
    If the two expressions are equal, `assert_ne!` macro will invoke `panic!` macro and the test will be marked as failed.
    
    ```rust
    // Example 5: `assert_ne!` macro usage
    
    #[test]
    fn fail_test() {
      let a = 1; let b = 3;
    
      // left expression `a + b` is equal
      //   to right expression `4`
      // Thus, `assert_ne!` macro will
      //   invoke `panic!` macro
      assert_ne!(a + b, 4);
    }
    
    #[test]
    fn pass_test() {
      let a = 2; let b = 2;
    
      // left expression `a + b` is "not equal"
      //   to right expression `5`
      // Thus, `assert_eq!` macro will
      //   not invoke `panic!` macro
      assert_ne!(a + b, 5);
    }
    ```
    
4. `should_panic` attribute  
    The `should_panic` attribute allows us to check if the code inside the test function invokes `panic!` macro when it's supposed to.
    
      
    When the code inside the test function invokes `panic!` macro, our test is not marked as failed, the `should_panic` attribute marks the test as "passed" because panic was expected.
    
      
    To add the `should_panic` attribute to a function, we can simply place it on a new line after the `test` attribute. Refer to below code snippet -
    
    ```rust
    // Example 6: `should_panic` attribute usage
    
    #[test]
    #[should_panic]
    fn passed_test() {
      let a = 1; let b = 3;
    
      // expression `a + b != 4`
      //   evaluates to `false`
      // Therfore, `assert!` macro
      //   will invoke `panic!` macro
      assert!(a + b != 4);
    
      // This test will be marked
      //   as "passed" because
      // panic is "expected" and also "triggered"
    }
    
    #[test]
    #[should_panic]
    fn failed_test() {
      let a = 2; let b = 2;
    
      // expression `a + b == 4`
      //   evaluates to `true`
      // Therfore, `assert!` macro will
      //   not invoke `panic!` macro
      assert!(a + b == 4);
    
      // This test will be marked
      //    as "failed" because
      // `should_panic` attribute is present,
      //    indicating that a panic is expected
      // However, in this test, the
      //    panic was not "triggered".
    }
    ```
    
    In Rust, panic can be triggered for various reasons. With `should_panic` attribute, we can also check if a panic was triggered for a specific reason.
    
      
    If the panic happens as expected for that reason, the test will pass. However, the test will be marked as failed if the panic occurs for a different reason or doesn't happen at all.
    
      
    Refer to below code snippet for example -
    
    ```rust
    // Example 7: `should_panic` attribute usage with specific reason
    
    #[test]
    #[should_panic("a is not equal to b")]
    fn passed_test() {
      let a = 1; let b = 2;
      if a != b {
        panic!("a is not equal to b");
      }
      // This test will be marked
      //    as "passed" because
      // "panic was triggered for
      //    the expected reason"
    }
    
    #[test]
    #[should_panic("a is not equal to b")]
    fn failed_test() {
      let a = 1; let b = 2;
      if a != b {
        panic!("a is not equal to 2");
      }
      // This test will be marked
      //    as "failed" because
      // panic was triggered for a
      //    different reason
      // than the expected reason specified
    }
    ```
    

The `assert!`, `assert_eq!` and `assert_ne!` macros also allow us to provide custom error messages. When these macros invoke `panic!` macro, they pass along the custom message we provided. This helps us to provide descriptive error messages when a test fails.

After providing the required parameters to the `assert!`, `assert_eq!`, and `assert_ne!` macros, we can pass a custom error message. Any additional arguments provided after the custom message will be passed to the *placeholders*("{}") present in the error message *string*, allowing us to create more detailed and dynamic error messages.

Refer to below code snippet for usage examples -

```rust
// Example 8: Passing custom error
//   message to assertion macros

#[test]
fn assert_with_error_msg() {
  assert!(
    2 > 3, // expression to evaluate
    "2 is not less than 3" // custom message
  );

  assert_eq!(
    2, // left expression
    3, // right expression
    "{} is not less than {}", // custom message
    2, // value to pass to first placeholder
    3 // value to pass to second placeholder
  );

  assert_ne!(
    2, // left expression
    2, // right expression
    "" // custom message
  );
}
```

## Organizing Integration Tests

In !\[Where to Write Tests\](#where-to-write-tests) section, we discussed where to put your tests. However, that applies only to unit tests and not Integration tests.

In Rust, Integration tests are for testing "library crates" and not binary crates, using our library crate like any other external code would. This means in integration tests, we can only use public API functions of our library crate.

In

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1685864591887/5b91fbbb-71e6-4662-9c84-b70baf1dfc27.png align="center")

---

## If you liked this Blog

This is my first blog. Liking and sharing this blog will encourage me to write more and more. Thank you.

You can connect with me on Twitter and LinkedIn